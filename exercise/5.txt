5.1
*yp = 0;
*xp = 0;

5.2
60 + 35n = 136 + 4n => 31n = 76 => n = 76/31
136 + 4n = 157 + 1.25n => 11/4 * n = 21 => n = 84/11
n = integer
n <= 2 版本1最快
3 <= n <= 7 版本2最快
n >= 8版本3最快

5.3
code        min     max     incr        square
A           1       91      90         90
B           91     1        90         90
C           1       1       90         90

5.4
A.  没有不同
B.  实现了
C.  只省略了读取*dest的过程

5.5
A.  2n      2n
B.  double乘法 延迟为5

5.6
A.  n   n
B.   5 + 3
C.  o

5.8
CPE1 = 5 * 3 / 3= 5
CPE2 = 5 * 2 / 3= 10/3 = 3.33
CPE3 = 5 / 3 = 1.67
CPE4 = 5 / 3 = 1.67
CPE5 = 5 * 2 / 3= 3.33

5.9
dest[id++] = src1[i1] < src2[i2] ? src1[i1++] : src2[i2++];

5.10
A. a[1...999,999]  a[i] = i + 1; a[999] = 999;
B. a[i] = 0
C. B的加载和存储使用了同一个地址：
D. 1.2CPE
